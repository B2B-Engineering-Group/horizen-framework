/**
 * Это шаблонный контроллер с описанием всех возможных параметров, все обязательны.
 * Когда на сервер приходит API запрос, выполняется один из таких контроллеров.
 * 
 * 1. Контроллеры которые находятся в этой папке автоматически импортируются 
 * в процесс при запуске, но их все еще необходимо подключить в процессе.
 * 
 * 2. Контроллеры работают только по методам POST (90% случаев) и GET (10% случаев, 
 * обычно для геттеров файлов). Метод указывается при подключении.
 * 
 * 3. Статус ответа на запрос всегда 200, даже если произошла ошибка (если процесс не упал).
 * 
 * 4. Контроллеры тестируются через e2e тесты процесса, эмулируя 
 *    бизнес-цепочки пути пользователя.
 * 
 * 5. Старайтесь оставлять в контроллерах минимум логики, а все выносить максимум в сервисы.
 **/
export default function({db, bankExample}){//Зависимости (сервисы) передаются через функцию процесса
	return {
		endpoint: "/api/getHello",//Путь по которому слушаем запросы

		//Тип авторизации, в данном случае авторизация скипается.
		//Если указать "authorized", автоматически заведется. 
		//Просто установите, запустите и откройте фронт в браузере.
		//Доступы при авторизации управляются внешним модулем.
		auth: "bypass",

		//Описание контроллера, своими словами
		description: "Возвращает приветствие",

		//Список кастомных ошибок.
		errors: {
			"customError": "Описание кастомной ошибки"
		},
		
		//Схема запроса. Если запрос не будет соответствовать схеме, будет отправлена ошибка валидатора.
		//Если в config.json есть debug: true, ответ будет дополнен информацией о месте ошибки.
		reqSchema: ({string, object, array, number, any}, {anyString})=> ({
			example: string(/.{1,100}/).optional(),
		}),

		//Схема ответа. Если ответ не будет соответствовать схеме, процесс упадет
		resSchema: ({string, object, array, number, any}, {anyString})=> ({
			text: anyString()
		}),

		//Если запрос прошел проверки (валидация, доступ), будет выполнен контроллер
		//В body лежат POST параметры, либо GET параметры.
		//В auth лежит userId если запрос прошел авторизацию
		controller: async function({body, auth}){
			//Запрос к коллекции demo в mongoDB (используйте методы классического драйвера)
			//await db("demo").insert({text: "Hello world!"});
			//await db("demo").find({}).toArray();

			//throw new Error("customError"); - Вызов кастомной ошибки из объекта errors.
			//В ответе придет {errored: true, code: "customError", text: "Описание кастомной ошибки"}
			//Если вы вызовете ошибку которой нет в описании, придет code: "500", text: "internal server error"

			//Объект который нужно отправить в ответе
			//Учитывайте, что он будет кастомизирован под {success: true, result: {...то что вы укажете ниже}}
			return {text: "Hello world! " + body.example}

		}
	}
}


/**
 * ===========================
 * Работа с типами (валидатор)
 * ===========================
 * 
 * Все схемы запросов/ответов указываются в едином формате. Есть базовые типы и кастомные типы. Базовые типы доступны сразу и передаются в первом параметре функции. Кастомные типы (их делаете вы для высокоуровневых моделей) передаются во втором параметре.

 * //Для JSON 
 * ({string, number, boolean, array, object, any}, {anyString})=> ({
 * 		message: string(/.{1,100}/).optional() //Любая строка длиной от 1 до 100 символов
 * 		users: array(object({//Массив объектов длиной от 1 до 10
 * 		userId: anyString(),//кастомный тип
 * 		name: string(/.{1,100}/)
 * 		intId: number(/([0-9]+){1,100}/)
 * 	})).length(1, 10)
 * }),	

 * //Для файлов (для reqSchema). Файл будет загружен из multipart/form-data, в body вы увидите {blob, filename}
 * //Из блоба вы всегда можете получить mime и размер файла, а filename представляет из себя оригинальное название у пользователя. 
 * ({file}, {})=> (file({
 *  	maxSizeMb: 1, 
 * 		mimetypes: ["*"]
 * 	})	
 * 
 * //По аналогии, чтобы отправить файл в ответе контроллера, необходимо вернуть объект вида {blob, filename} и указать тип file в resSchema. 
 * //На ответы валидация по mime и размеру не распространяется.
 * 
 * Также в сервисе gfs, который передается при инициализации фреймворка есть набор функций для удобного сохранения 
 * и выгрузки файлов из базы данных (GridFs) по тому же принципу.
 * 
 * У валидатора есть определенные ограничения. Объекты не могут иметь динамичные поля. 
 * Корневая сущность это всегда объект, либо file. Подобные ограничения необходимы для поддержки глобальной архитектуры, 
 * они редко доставляют дискомфорт, но иногда приходится дольше думать над архитектурой чтобы учесть эти особенности.
 * 
 * (!) Тип any() преимущественно используется для этапов разработки, пока модель данных находится в процессе изменения. 
 * 	   Использовать его в продакшене можно только в исключительных случаях по согласованию с системным архитектором. 
 * 	   Не смотря на то, что он присутствует даже в корневых методах фреймворка, любое использование any() является черным 
 *     ящиком на этапе интеграции.
 * 
 * (!) Больше информации вы можете получить изучив сервис валидатора в .horizen-framework/backend/services/Validator
 **/


/**
 * ===========================
 * Подробнее про свойство auth (тип проверки доступа):
 * ===========================
 * 
 * По умолчанию каждый микросервис интегрируются в нашу инфраструктуру. 
 * В ней уже есть набор микросервисов отвечающий за идентификацию/аутентификацию и авторизацию запросов, 
 * а также за конфигурацию этих параметров. Поэтому при поступлении любого запроса на 
 * указанный API, фреймворк сам проверит есть ли доступ у пользователя (или другого микросервиса) на этот запрос. 
 * Вам не требуется думать про это глобально, достаточно определить какой тип авторизации вам нужен для каждого контроллера 
 * в зависимости от его цели, все остальное будет сделано за вас.
 * 
 * Поддерживаемые типы:
 *    bypass - означает что это публичный контроллер. Никаких проверок нет.
 *    authorized - для авторизованных пользователей и микросервисов.
 *    authorized:user - только для авторизованных пользователей
 *    auhtorized:app - только для авторизованных микросервисов
 * 
 * В пунктах подразумевающих авторизацию, при исполнении контроллера вы получите одноименный объект auth, 
 * содержащий {userId: INT} или {appId: INT} (appId используется только для интеграционных модулей).
 * 
 * Реальный пример работы: 
 * 
 * Пользователь на фронтенде жмет на кнопку и происходит API запрос. 
 * Фреймворк запускает внутренние механизмы проверки токена из заголовков запроса и в случае успеха выполняет код внутри метода controller. 
 * Если пользователь не авторизован то сообщается специальный код ошибки, который ловится фреймворком на фронтенде 
 * и редиректит пользователя на oAuth страницу входа (если не аутентифицирован) или на страницу 403 ошибки.
 * 
 **/
